/*********************************************************************
This is a library for our Monochrome OLEDs based on SSD1306 drivers

  Pick one up today in the adafruit shop!
  ------> http://www.adafruit.com/category/63_98

These displays use SPI to communicate, 4 or 5 pins are required to  
interface

Adafruit invests time and resources providing this open source code, 
please support Adafruit and open-source hardware by purchasing 
products from Adafruit!

Written by Limor Fried/Ladyada  for Adafruit Industries.  
BSD license, check license.txt for more information
All text above, and the splash screen below must be included in any redistribution
*********************************************************************/

/*
 *  Modified by Neal Horman 7/14/2012 for use in mbed
 *  Converted to RUST by Mariwan Jalal 18/07/2025 for Nucleo-STM32F767ZI
 */

#![no_std]

use crate::adafruit_gfx_config::NO_SPLASH_ADAFRUIT;
use crate::adafruit_gfx_h::AdafruitGFX;
use crate::adafruit_ssd1306_h::*;
use embedded_hal::{ delay::DelayNs };
use embedded_hal_old::blocking::i2c;

use core::cmp::min;

use core::result::Result;
use crate::adafruit_ssd1306::Result::Ok;

use stm32f7xx_hal::{ gpio::{ Output, PushPull, PB11, PG6 } };

pub enum SSD1306Commands {
    SSD1306_SETCONTRAST = 0x81,
    SSD1306_DISPLAYALLON_RESUME = 0xa4,
    SSD1306_DISPLAYALLON = 0xa5,
    SSD1306_NORMALDISPLAY = 0xa6,
    SSD1306_INVERTDISPLAY = 0xa7,
    SSD1306_DISPLAYOFF = 0xae,
    SSD1306_DISPLAYON = 0xaf,
    SSD1306_SETDISPLAYOFFSET = 0xd3,
    SSD1306_SETCOMPINS = 0xda,
    SSD1306_SETVCOMDETECT = 0xdb,
    SSD1306_SETDISPLAYCLOCKDIV = 0xd5,
    SSD1306_SETPRECHARGE = 0xd9,
    SSD1306_SETMULTIPLEX = 0xa8,
    SSD1306_SETLOWCOLUMN = 0x00,
    SSD1306_SETHIGHCOLUMN = 0x10,
    SSD1306_SETSTARTLINE = 0x40,
    SSD1306_MEMORYMODE = 0x20,
    SSD1306_COMSCANINC = 0xc0,
    SSD1306_COMSCANDEC = 0xc8,
    SSD1306_SEGREMAP = 0xa0,
    SSD1306_CHARGEPUMP = 0x8d,
    
    //Scrolling
    SSD1306_HORIZONTAL_SCROLL_R = 0x26,
    SSD1306_HORIZONTAL_SCROLL_L = 0x27,
    
    SSD1306_VERTICAL_R_SCROLL = 0x29,
    SSD1306_VERTICAL_L_SCROLL = 0x2a,
    
    SSD1306_VERTICAL_SCROLL_AREA = 0xa3,

    SSD1306_ACTIVATE_SCROLL = 0x2f,
    SSD1306_DEACTIVATE_SCROLL = 0x2e,
}
use SSD1306Commands::*;
use cortex_m::{ delay::Delay as CortexDelay, prelude::_embedded_hal_blocking_i2c_Write };

//Work around problems you get due to mismatch of trait and HAL - Start
pub struct DelayWrapper {
    inner: CortexDelay,
}

impl DelayWrapper {
    pub fn new(inner: CortexDelay) -> Self {
        DelayWrapper { inner }
    }
}

impl DelayNs for DelayWrapper {
    fn delay_ns(&mut self, ns: u32) {
        // Convert ns to us, call inner delay_us (embedded-hal 0.2)
        let us = (ns + 999) / 1000; // round up ns -> us
        self.inner.delay_us(us);
    }
}

//----------------
pub trait MyGpioPin {
    fn set_high(&mut self) -> Result<(), Self::Error>;
    fn set_low(&mut self) -> Result<(), Self::Error>;
    fn toggle(&mut self) -> Result<(), Self::Error>;
    fn is_set_high(&self) -> Result<bool, Self::Error>;
    type Error;
}
impl MyGpioPin for PB11<Output<PushPull>> {
    type Error = ();

    fn set_high(&mut self) -> Result<(), Self::Error> {
        self.set_high();
        Ok(())
    }

    fn set_low(&mut self) -> Result<(), Self::Error> {
        self.set_low();
        Ok(())
    }

    fn toggle(&mut self) -> Result<(), Self::Error> {
        // Toggle implementation might depend on the specific pin
        if self.is_set_high() {
            Ok(())
        } else {
            self.set_high();
            Ok(())
        }
    }

    fn is_set_high(&self) -> Result<bool, Self::Error> {
        // You may need to implement this depending on your pin type
        Ok(true) // Placeholder; replace with actual logic
    }
}

//---------------------------
#[derive(Debug)]
pub enum AdafruitSSD1306Error<E> {
    CommandTooLong,
    I2cError(E), // Wrap the specific I2C error type
}

impl<I2C, GPIO, DELAY, E> Display<I2C, GPIO, DELAY>
    for AdafruitSSD1306<I2C, GPIO, DELAY>
    where
        DELAY: DelayNs, // Ensure DELAY implements the required trait
        GPIO: MyGpioPin, // Ensure GPIO implements the required GPIO pin trait
        I2C: i2c::Write<Error = E> + i2c::WriteRead<Error = E> // Combined Write and WriteRead
{
    fn new(ni2c: I2C, n_rst: GPIO, delay: DELAY, ngfx: AdafruitGFX) -> Self {
        AdafruitSSD1306 {
            rst: n_rst,
            i2c: ni2c,
            address: 0x3c,
            delay,
            gfx: ngfx,
        }
    }

    fn begin(&mut self, vccstate: u8) {
        let _ = self.rst.set_high();
        // VDD (3.3V) goes high at start, lets just chill for a ms
        self.delay.delay_ms(1u32);

        // Bring reset low
        self.rst.set_low();
        // Wait 10ms
        self.delay.delay_ms(10u32);

        // Bring out of reset
        self.rst.set_high();

        self.command(SSD1306_DISPLAYOFF as u8);
        self.command(SSD1306_SETDISPLAYCLOCKDIV as u8);
        self.command(0x80); // The suggested ratio 0x80

        self.command(SSD1306_SETMULTIPLEX as u8);
        self.command((self.gfx.raw_height as u8) - 1);

        self.command(SSD1306_SETDISPLAYOFFSET as u8);
        self.command(0x0); // No offset

        self.command((SSD1306_SETSTARTLINE as u8) | 0x0); // Line #0

        self.command(SSD1306_CHARGEPUMP as u8);
        self.command(if vccstate == SSD1306_EXTERNALVCC { 0x10 } else { 0x14 });

        self.command(SSD1306_MEMORYMODE as u8);
        self.command(0x00); // 0x0 acts like KS0108

        self.command((SSD1306_SEGREMAP as u8) | 0x1);
        self.command(SSD1306_COMSCANDEC as u8);

        self.command(SSD1306_SETCOMPINS as u8);
        self.command(if self.gfx.raw_height == 32 { 0x02 } else { 0x12 }); // Calculate based on _rawHeight

        self.command(SSD1306_SETCONTRAST as u8);
        self.command(
            if self.gfx.raw_height == 32 {
                0x8f
            } else {
                if vccstate == SSD1306_EXTERNALVCC { 0x9f } else { 0xcf }
            }
        );

        self.command(SSD1306_SETPRECHARGE as u8);
        self.command(if vccstate == SSD1306_EXTERNALVCC { 0x22 } else { 0xf1 });

        self.command(SSD1306_SETVCOMDETECT as u8);
        self.command(0x40);

        self.command(SSD1306_DISPLAYALLON_RESUME as u8);
        self.command(SSD1306_NORMALDISPLAY as u8);
        self.command(SSD1306_DISPLAYON as u8);
    }

    fn invert_display(&mut self, i: bool) {
        self.command(if i { SSD1306_INVERTDISPLAY as u8 } else { SSD1306_NORMALDISPLAY as u8 });
    }

    // Send the display buffer out to the display
    fn show(&mut self) {
        self.command((SSD1306_SETLOWCOLUMN as u8) | 0x0); // Low column = 0
        self.command((SSD1306_SETHIGHCOLUMN as u8) | 0x0); // High column = 0
        self.command((SSD1306_SETSTARTLINE as u8) | 0x0); // Line #0
        self.send_display_buffer();
    }

    // Clear the display buffer. Requires a display() call at some point afterwards
    fn clear_display(&mut self) {
        self.gfx.buffer.fill(0);
    }
    //TODO: Don't forget to change this if you have 128x64 oLED
    fn copy_adafruit_logo(&mut self, ada_fruit_logo: &[u8], raw_height: i16) {
        // Determine the number of elements to copy
        let length = if raw_height == 32 { ada_fruit_logo.len() / 2 } else { ada_fruit_logo.len() };

        // Copy the elements
        self.gfx.buffer[..length].copy_from_slice(&ada_fruit_logo[..length]);
    }
    
    //TODO: Don't forget to change this if you have 128x64 oLED
    fn splash(&mut self) {
        if !NO_SPLASH_ADAFRUIT {
            let ada_fruit_logo: [u8; 1024] = [  //128*64
                //128*32
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xc0,
                0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc,
                0xf8, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00,
                0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,
                0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0xff,
                0xff, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8c, 0x8e, 0x84, 0x00, 0x00,
                0x80, 0xf8, 0xf8, 0xf8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
                0xf0, 0xf0, 0xe0, 0xe0, 0xc0, 0x80, 0x00, 0xe0, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0x7f,
                0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xc7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xff,
                0xff, 0x00, 0x00, 0x7c, 0xfe, 0xc7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xff, 0xff, 0xff,
                0x00, 0x38, 0xfe, 0xc7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xc7, 0xff, 0xff, 0x00, 0x00,
                0x01, 0xff, 0xff, 0x01, 0x01, 0x00, 0xff, 0xff, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00,
                0x7f, 0xff, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xff, 0xff, 0xff,
                0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0f, 0x3f, 0x7f, 0x7f, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xe7, 0xc7, 0xc7, 0x8f, 0x8f, 0x9f, 0xbf, 0xff, 0xff, 0xc3,
                0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
                0xfc, 0xf8, 0xf8, 0xf0, 0xf0, 0xe0, 0xc0, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03,
                0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
                0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03,
                0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01,
                0x03, 0x01, 0x00, 0x00, 0x00, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                //128x32^^^  128x64vvv
                0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
                0x1f, 0x0f, 0x87, 0xc7, 0xf7, 0xff, 0xff, 0x1f, 0x1f, 0x3d, 0xfc, 0xf8, 0xf8, 0xf8,
                0xf8, 0x7c, 0x7d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x0f,
                0x07, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe,
                0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xc0, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0xc0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0x7f, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x1f, 0x7f, 0xff, 0xff, 0xf8, 0xf8, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xfe, 0xf8, 0xe0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xfc, 0x0c, 0x06,
                0x06, 0x0e, 0xfc, 0xf8, 0x00, 0x00, 0xf0, 0xf8, 0x1c, 0x0e, 0x06, 0x06, 0x06, 0x0c,
                0xff, 0xff, 0xff, 0x00, 0x00, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xfc,
                0x00, 0x18, 0x3c, 0x7e, 0x66, 0xe6, 0xce, 0x84, 0x00, 0x00, 0x06, 0xff, 0xff, 0x06,
                0x06, 0xfc, 0xfe, 0xfc, 0x0c, 0x06, 0x06, 0x06, 0x00, 0x00, 0xfe, 0xfe, 0x00, 0x00,
                0xc0, 0xf8, 0xfc, 0x4e, 0x46, 0x46, 0x46, 0x4e, 0x7c, 0x78, 0x40, 0x18, 0x3c, 0x76,
                0xe6, 0xce, 0xcc, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0f, 0x1f,
                0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1f, 0x0f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f,
                0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x03, 0x07, 0x0e, 0x0c, 0x18, 0x18,
                0x0c, 0x06, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x01, 0x0f, 0x0e, 0x0c, 0x18, 0x0c, 0x0f,
                0x07, 0x01, 0x00, 0x04, 0x0e, 0x0c, 0x18, 0x0c, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x0f,
                0x0f, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f,
                0x00, 0x00, 0x00, 0x07, 0x07, 0x0c, 0x0c, 0x18, 0x1c, 0x0c, 0x06, 0x06, 0x00, 0x04,
                0x0e, 0x0c, 0x18, 0x0c, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ];
            self.copy_adafruit_logo(&ada_fruit_logo, self.gfx.raw_height);
        }
    }

    fn command(&mut self, c: u8) {
        let mut buff = [0; 2];
        buff[0] = 0; // Command Mode
        buff[1] = c;
        let _ = self.i2c.write(self.address, &buff);
    }

    fn data(&mut self, c: u8) {
        let mut buff = [0; 2];
        buff[0] = 0x40; // Data Mode
        buff[1] = c;
        let _ = self.i2c.write(self.address, &buff);
    }

    fn send_display_buffer(&mut self) {
        let mut buff = [0; 17];
        buff[0] = 0x40; // Data Mode
        let len = self.gfx.buffer.len();
        // Send display buffer in 16-byte chunks
        let mut i = 0;
        while i < len {
            for x in 1..16 {
                buff[x] = self.gfx.buffer[i + x - 1];
            }
            let _e = self.i2c.write(self.address, &buff); // Send only the filled part
            i += 16;
        }
    }

    fn activate_scroll(&mut self) {
        self.command(SSD1306_ACTIVATE_SCROLL as u8);
    }
    fn deactivate_scroll(&mut self) {
        self.command(SSD1306_DEACTIVATE_SCROLL as u8);
    }
    fn scroll_horizontal_r(&mut self) {
        self.deactivate_scroll();
        self.command(SSD1306_HORIZONTAL_SCROLL_R as u8); // 0x26
        self.command(0x0);    // Dummy byte
        self.command(0x0);    // Start from page 0
        self.command(0x0);    // Time Interval
        self.command(0x7);    // Last Page
        self.command(0x0);    // dummy
        self.command(0xff);    // dummy
        self.activate_scroll(); // Activate scrolling
    }

    fn scroll_horizontal_l(&mut self) {
        self.deactivate_scroll();
        self.command(SSD1306_HORIZONTAL_SCROLL_L as u8); // 0x27
        self.command(0x0);    // Dummy byte
        self.command(0x0);    // Start from page 7 (if scrolling left)
        self.command(0x0);    // Time Interval
        self.command(0x7);    // Last Page (consider your display's configuration)
        self.command(0x0);    // dummy
        self.command(0xff);    // dummy
        self.activate_scroll(); // Activate scrolling
    }
    fn scroll_diagnol_r(&mut self) {
        self.deactivate_scroll();

            // Set up the vertical scrolling
        self.command(SSD1306_VERTICAL_R_SCROLL as u8); // Command for vertical scroll up
        self.command(0x0);    // Dummy byte
        self.command(0x0);    // First Page (starting from page 0)
        self.command(0x0);    // Time Interval (5 frames/sec)
        self.command(0x7);    // Last Page (0x7 for an 8-page display)
        self.command(0x1);    // Vertical scrolling offset (1 row)
    self.activate_scroll(); // Activate scrolling
    }
    
    fn scroll_diagnol_l(&mut self) {
        self.deactivate_scroll();
        

        // Now set up the vertical scrolling down
        self.command(SSD1306_VERTICAL_L_SCROLL as u8); // Command for vertical scroll down
        self.command(0x0);    // Dummy
        self.command(0x0);    // First Page (starting from page 0)
        self.command(0x0);    // Time Interval (5 frames/sec)
        self.command(0x7);    // Last Page (0x7 for an 8-page display)
        self.command(0x1);    // Vertical scrolling offset (1 row)
        self.activate_scroll(); // Activate scrolling
    }

 fn scroll_vertical_u(&mut self) {
    self.deactivate_scroll();
    
    self.command(SSD1306_VERTICAL_R_SCROLL as u8);
    self.command(0x0);    // Dummy byte
    self.command(0x7);    // First Page
    self.command(0x0);    // Time Interval
    self.command(0x7);    // Last Page
    self.command(0x1);    // Vertical offset

    self.activate_scroll();
}

}
